/*
 * Wazuh Vulnerability scanner - Scan Orchestrator
 * Copyright (C) 2015, Wazuh Inc.
 * Jan 22, 2024.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#ifndef __QUERY_ALL_PKGS_FOR_AGT_HPP
#define __QUERY_ALL_PKGS_FOR_AGT_HPP

#include "chainOfResponsability.hpp"
#include "loggerHelper.h"
#include "scanContext.hpp"
#include "socketDBWrapper.hpp"
#include "vulnerabilityScanner.hpp"
#include "wazuhDBQueryBuilder.hpp"

/**
 * @brief Orchestrates queries over the global Wazuh system and initiates scanners for each package.
 *
 * This class is responsible for managing the execution of queries within the global Wazuh environment.
 * It leverages a scanner mechanism to analyze each package encountered during the query process.
 *
 *
 * @tparam TScanContext scan context type.
 */
template<typename TScanContext = ScanContext>
class TQueryAllPkgForAgent final : public AbstractHandler<std::shared_ptr<TScanContext>>
{
private:
    std::shared_ptr<AbstractHandler<std::shared_ptr<ScanContext>>> m_suborchestration;
    std::optional<SocketDBWrapper> m_wdbSocketWrapper {std::nullopt};

public:
    /**
     * @brief Construct a new global fetch object
     *
     * @param packageInsertOrchestration package orchestration instance.
     */
    explicit TQueryAllPkgForAgent(
        std::shared_ptr<AbstractHandler<std::shared_ptr<ScanContext>>> packageInsertOrchestration)
        : m_suborchestration(std::move(packageInsertOrchestration))
    {
    }

    /**
     * @brief Handles request and passes control to the next step of the chain.
     *
     * @param data Scan context.
     * @return std::shared_ptr<TScanContext> Abstract handler.
     */
    std::shared_ptr<TScanContext> handleRequest(std::shared_ptr<TScanContext> data) override
    {
        // Instance the socketWrapper for wazuhDb
        if (!m_wdbSocketWrapper)
        {
            try
            {
                m_wdbSocketWrapper.emplace(WDB_SOCKET);
            }
            catch (const std::exception& e)
            {
                logError(WM_VULNSCAN_LOGTAG, "Error creating socketDBWrapper: %s", e.what());
            }
        }

        // Iterate over all agents
        for (const auto& agent : data->getMessages())
        {
            // Execute query for all packages
            nlohmann::json response;
            m_wdbSocketWrapper->query(WazuhDBQueryBuilder::builder().agentGetPackagesCommand(agent["id"]).build(),
                                      response);

            // Validate the response
            if (response.empty())
            {
                logWarn(
                    WM_VULNSCAN_LOGTAG, "Empty response for agent '%s' in Wazuh-DB 'sys_programs' query", agent["id"]);
                continue;
            }

            for (auto package : response)
            {
                flatbuffers::FlatBufferBuilder fbBuilder;
                auto agentInfo =
                    SyscollectorSynchronization::CreateAgentInfoDirect(fbBuilder,
                                                                       agent.value("id", "").c_str(),
                                                                       agent.value("ip", "").c_str(),
                                                                       agent.value("name", "").c_str(),
                                                                       agent.value("version", "").c_str(),
                                                                       agent.value("node_name", "").c_str());
                auto syscollectorPackage = SyscollectorSynchronization::Createsyscollector_packagesDirect(
                    fbBuilder,
                    package.value("architecture", "").c_str(),
                    package.value("checksum", "").c_str(),
                    package.value("description", "").c_str(),
                    package.value("format", "").c_str(),
                    package.value("groups", "").c_str(),
                    package.value("install_time", "").c_str(),
                    package.value("item_id", "").c_str(),
                    package.value("location", "").c_str(),
                    package.value("multiarch", "").c_str(),
                    package.value("name", "").c_str(),
                    package.value("priority", "").c_str(),
                    package.value("scan_time", "").c_str(),
                    package.value("size", 0),
                    package.value("source", "").c_str(),
                    package.value("vendor", "").c_str(),
                    package.value("version", "").c_str());

                auto stateMsg = SyscollectorSynchronization::Createstate(
                    fbBuilder,
                    SyscollectorSynchronization::AttributesUnion::AttributesUnion_syscollector_packages,
                    syscollectorPackage.Union());

                auto syncMsg = SyscollectorSynchronization::CreateSyncMsg(
                    fbBuilder, agentInfo, SyscollectorSynchronization::DataUnion::DataUnion_state, stateMsg.Union());

                fbBuilder.Finish(syncMsg);

                std::variant<const SyscollectorDeltas::Delta*,
                             const SyscollectorSynchronization::SyncMsg*,
                             std::shared_ptr<nlohmann::json>>
                    variantData = SyscollectorSynchronization::GetSyncMsg(fbBuilder.GetBufferPointer());

                auto context = std::make_shared<ScanContext>(variantData);
                m_suborchestration->handleRequest(std::move(context));
            }
        }
        return AbstractHandler<std::shared_ptr<TScanContext>>::handleRequest(std::move(data));
    }
};

using QueryAllPkgForAgent = TQueryAllPkgForAgent<>;

#endif // __QUERY_ALL_PKGS_FOR_AGT_HPP