/*
 * Wazuh Vulnerability scanner - Scan Orchestrator
 * Copyright (C) 2015, Wazuh Inc.
 * Jan 22, 2024.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#ifndef __CLEAN_UP_ALL_HPP
#define __CLEAN_UP_ALL_HPP

#include "chainOfResponsability.hpp"
#include "loggerHelper.h"
#include "scanContext.hpp"
#include "socketDBWrapper.hpp"
#include "vulnerabilityScanner.hpp"
#include "wazuhDBQueryBuilder.hpp"

/**
 * @brief Orchestrates queries over the global Wazuh system and initiates scanners for each package.
 *
 * This class is responsible for managing the execution of queries within the global Wazuh environment.
 * It leverages a scanner mechanism to analyze each package encountered during the query process.
 *
 *
 * @tparam TScanContext scan context type.
 */
template<typename TScanContext = ScanContext>
class TCleanUpAllData final : public AbstractHandler<std::shared_ptr<TScanContext>>
{
private:
    std::shared_ptr<AbstractHandler<std::shared_ptr<ScanContext>>> m_suborchestration;
    std::optional<SocketDBWrapper> m_wdbSocketWrapper {std::nullopt};

public:
    /**
     * @brief Construct a new global fetch object
     *
     * @param packageInsertOrchestration package orchestration instance.
     */
    explicit TCleanUpAllData(std::shared_ptr<AbstractHandler<std::shared_ptr<ScanContext>>> packageInsertOrchestration)
        : m_suborchestration(std::move(packageInsertOrchestration))
    {
    }

    /**
     * @brief Handles request and passes control to the next step of the chain.
     *
     * @param data Scan context.
     * @return std::shared_ptr<TScanContext> Abstract handler.
     */
    std::shared_ptr<TScanContext> handleRequest(std::shared_ptr<TScanContext> data) override
    {
        // Instance the socketWrapper for wazuhDb
        if (!m_wdbSocketWrapper)
        {
            try
            {
                m_wdbSocketWrapper.emplace(WDB_SOCKET);
            }
            catch (const std::exception& e)
            {
                logError(WM_VULNSCAN_LOGTAG, "Error creating socketDBWrapper: %s", e.what());
            }
        }

        // Iterate over all agents
        for (const auto& agent : data->getMessages())
        {
            flatbuffers::FlatBufferBuilder fbBuilder;
            auto agentInfo = SyscollectorSynchronization::CreateAgentInfoDirect(fbBuilder,
                                                                                agent.value("id", "").c_str(),
                                                                                agent.value("ip", "").c_str(),
                                                                                agent.value("name", "").c_str(),
                                                                                agent.value("version", "").c_str(),
                                                                                agent.value("node_name", "").c_str());

            auto syscollectorIntegrityClear =
                SyscollectorSynchronization::Createintegrity_clearDirect(fbBuilder, "syscollector_packages", 0);

            auto syncMsg = SyscollectorSynchronization::CreateSyncMsg(
                fbBuilder,
                agentInfo,
                SyscollectorSynchronization::DataUnion::DataUnion_integrity_clear,
                syscollectorIntegrityClear.Union());

            fbBuilder.Finish(syncMsg);

            std::variant<const SyscollectorDeltas::Delta*,
                         const SyscollectorSynchronization::SyncMsg*,
                         std::shared_ptr<nlohmann::json>>
                variantData = SyscollectorSynchronization::GetSyncMsg(fbBuilder.GetBufferPointer());

            auto context = std::make_shared<TScanContext>(variantData);
            m_suborchestration->handleRequest(std::move(context));
        }
        return AbstractHandler<std::shared_ptr<TScanContext>>::handleRequest(std::move(data));
    }
};

using CleanUpAllData = TCleanUpAllData<>;

#endif // __CLEAN_UP_ALL_HPP
