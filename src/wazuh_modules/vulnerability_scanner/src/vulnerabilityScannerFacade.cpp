/*
 * Wazuh Vulnerability scanner
 * Copyright (C) 2015, Wazuh Inc.
 * March 25, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#include "vulnerabilityScannerFacade.hpp"
#include "flatbuffers/include/syscollector_deltas_generated.h"
#include "flatbuffers/include/syscollector_synchronization_generated.h"
#include "loggerHelper.h"
#include "vulnerabilityScanner.hpp"
#include "wazuh_modules/vulnerability_scanner/src/policyManager/policyManager.hpp"

constexpr auto VULNERABILITY_SCANNER_TEMPLATE = "queue/indexer/vd_states_template.json";
constexpr auto DEFAULT_QUEUE_PATH = "queue/sockets/queue";
constexpr auto DELTA_EVENTS_QUEUE_PATH = "queue/vd/deltas";
constexpr auto SYNCHRONIZATION_EVENTS_QUEUE_PATH = "queue/vd/sync";

constexpr auto SLEEP_RETRY_THREADS_SEC = 60;

int SOCKET_WAIT = 0;
int MICROSEC_FACTOR = 1000000;

// TODO: Remove LCOV flags once the implementation of the 'Indexer Connector' module is completed
// LCOV_EXCL_START
void VulnerabilityScannerFacade::start(
    const std::function<void(
        const int, const std::string&, const std::string&, const int, const std::string&, const std::string&, va_list)>&
        logFunction,
    const nlohmann::json& configuration,
    const bool noWaitToStop)
{
    try
    {
        m_noWaitToStop = noWaitToStop;

        // Initialize logging
        Log::assignLogFunction(logFunction);

        // Policy manager initialization.
        auto& policyManager = PolicyManager::instance();
        policyManager.initialize(configuration);

        // Return if the module is disabled.
        if (!policyManager.isVulnerabilityDetectionEnabled())
        {
            logInfo(WM_VULNSCAN_LOGTAG, "Vulnerability scanner module is disabled");
            return;
        }

        // Indexer connector initialization.
        if (policyManager.isIndexerEnabled())
        {
            const auto& indexerConfig = policyManager.getIndexerConfiguration();
            m_indexerConnector =
                std::make_shared<IndexerConnector>(policyManager.getIndexerConfiguration(),
                                                   indexerConfig.contains("template_path")
                                                       ? indexerConfig.at("template_path").get_ref<const std::string&>()
                                                       : VULNERABILITY_SCANNER_TEMPLATE,
                                                   logFunction);
        }

        // Database feed manager initialization.
        m_databaseFeedManager =
            std::make_shared<DatabaseFeedManager>(m_indexerConnector, m_shouldStop, m_internalMutex);

        // Socket client initialization to send vulnerability reports.
        if (configuration.contains("wmMaxEps") && configuration.at("wmMaxEps").is_number())
        {
            SOCKET_WAIT = MICROSEC_FACTOR / configuration.at("wmMaxEps").get<int>();
        }
        m_reportSocketClient =
            std::make_shared<SocketClient<Socket<OSPrimitives, NoHeaderProtocol>, EpollWrapper>>(DEFAULT_QUEUE_PATH);
        m_reportSocketClient->connect(
            [](const char* data, uint32_t size, const char* dataHeader, uint32_t sizeHeader) {}, []() {}, SOCK_DGRAM);

        // Add subscribers for policy updates.
        policyManager.addSubscriber(m_databaseFeedManager);

        // Init Orchestrator
        auto scanOrchestrator = std::make_shared<ScanOrchestrator>(
            m_indexerConnector, m_databaseFeedManager, m_reportSocketClient, m_internalMutex);

        // Queues to process skipped events
        m_deltaQueue = std::make_shared<Utils::SafeQueue<std::string, RocksDBQueue<std::string>>>(
            RocksDBQueue<std::string>(DELTA_EVENTS_QUEUE_PATH));
        m_syncQueue = std::make_shared<Utils::SafeQueue<std::string, RocksDBQueue<std::string>>>(
            RocksDBQueue<std::string>(SYNCHRONIZATION_EVENTS_QUEUE_PATH));

        // Threads to retry skipped events
        m_deltaThread = std::thread(
            [scanOrchestrator, this]()
            {
                while (!m_stopRetryThread.load())
                {
                    for (int i = 0; i < SLEEP_RETRY_THREADS_SEC; ++i)
                    {
                        std::this_thread::sleep_for(std::chrono::seconds(1));
                        if (m_stopRetryThread.load())
                        {
                            break;
                        }
                    }

                    while (!m_deltaQueue->empty() && !m_stopRetryThread.load())
                    {
                        std::shared_ptr<std::string> returnStr = m_deltaQueue->pop();

                        flatbuffers::Verifier deltaVerifier(reinterpret_cast<const uint8_t*>(returnStr->c_str()),
                                                            returnStr->size());

                        if (SyscollectorDeltas::VerifyDeltaBuffer(deltaVerifier))
                        {
                            const SyscollectorDeltas::Delta* delta =
                                SyscollectorDeltas::GetDelta(reinterpret_cast<const char*>(returnStr->c_str()));
                            std::variant<const SyscollectorDeltas::Delta*, const SyscollectorSynchronization::SyncMsg*>
                                data = delta;

                            std::string packageName;
                            if (delta->data_as_dbsync_packages() && delta->data_as_dbsync_packages()->name())
                            {
                                packageName = delta->data_as_dbsync_packages()->name()->c_str();
                            }

                            try
                            {
                                logDebug1(WM_VULNSCAN_LOGTAG, "Retry dbsync_packages event: %s package", packageName);
                                scanOrchestrator->run(data);
                            }
                            catch (const std::exception& e)
                            {
                                logWarn(WM_VULNSCAN_LOGTAG,
                                        "Discarded dbsync_packages event: %s package. %s",
                                        packageName,
                                        e.what());
                            }
                        }
                    }
                }
            });

        m_syncThread = std::thread(
            [scanOrchestrator, this]()
            {
                while (!m_stopRetryThread.load())
                {
                    for (int i = 0; i < SLEEP_RETRY_THREADS_SEC; ++i)
                    {
                        std::this_thread::sleep_for(std::chrono::seconds(1));
                        if (m_stopRetryThread.load())
                        {
                            break;
                        }
                    }

                    while (!m_syncQueue->empty() && !m_stopRetryThread.load())
                    {
                        std::shared_ptr<std::string> returnStr = m_syncQueue->pop();

                        flatbuffers::Verifier syncVerifier(reinterpret_cast<const uint8_t*>(returnStr->c_str()),
                                                           returnStr->size());

                        if (SyscollectorSynchronization::VerifySyncMsgBuffer(syncVerifier))
                        {
                            const SyscollectorSynchronization::SyncMsg* syncMsg =
                                SyscollectorSynchronization::GetSyncMsg(
                                    reinterpret_cast<const char*>(returnStr->c_str()));
                            std::variant<const SyscollectorDeltas::Delta*, const SyscollectorSynchronization::SyncMsg*>
                                data = syncMsg;

                            std::string packageName;
                            if (syncMsg->data_as_state() &&
                                syncMsg->data_as_state()->attributes_as_syscollector_packages() &&
                                syncMsg->data_as_state()->attributes_as_syscollector_packages()->name())
                            {
                                packageName =
                                    syncMsg->data_as_state()->attributes_as_syscollector_packages()->name()->c_str();
                            }

                            try
                            {
                                logDebug1(
                                    WM_VULNSCAN_LOGTAG, "Retry syscollector_packages event: %s package", packageName);
                                scanOrchestrator->run(data);
                            }
                            catch (const std::exception& e)
                            {
                                logWarn(WM_VULNSCAN_LOGTAG,
                                        "Discarded syscollector_packages event: %s package. %s",
                                        packageName,
                                        e.what());
                            }
                        }
                    }
                }
            });

        // Subscription to syscollector delta events.
        m_syscollectorDeltasSubscription =
            std::make_unique<RouterSubscriber>("deltas-syscollector", "vulnerability_scanner_deltas");
        m_syscollectorDeltasSubscription->subscribe(
            [scanOrchestrator, this](const std::vector<char>& message)
            {
                const SyscollectorDeltas::Delta* delta = SyscollectorDeltas::GetDelta(message.data());
                std::variant<const SyscollectorDeltas::Delta*, const SyscollectorSynchronization::SyncMsg*> data =
                    delta;

                std::string packageName;
                if (delta->data_as_dbsync_packages() && delta->data_as_dbsync_packages()->name())
                {
                    packageName = delta->data_as_dbsync_packages()->name()->c_str();
                }

                try
                {
                    scanOrchestrator->run(data);
                }
                catch (const OsDataException& e)
                {
                    m_deltaQueue->push(std::move(std::string(message.data(), message.size())));
                    logDebug1(WM_VULNSCAN_LOGTAG,
                              "%s. dbsync_packages events postponed: %s package. Queue size: %d",
                              e.what(),
                              packageName,
                              m_deltaQueue->size());
                }
                catch (const std::exception& e)
                {
                    logError(WM_VULNSCAN_LOGTAG, "ScanOrchestrator::run::Exception: %s", e.what());
                }
            });

        // Subscription to syscollector rsync events.
        m_syscollectorRsyncSubscription =
            std::make_unique<RouterSubscriber>("rsync-syscollector", "vulnerability_scanner_rsync");
        m_syscollectorRsyncSubscription->subscribe(
            [scanOrchestrator, this](const std::vector<char>& message)
            {
                const SyscollectorSynchronization::SyncMsg* syncMsg =
                    SyscollectorSynchronization::GetSyncMsg(message.data());
                std::variant<const SyscollectorDeltas::Delta*, const SyscollectorSynchronization::SyncMsg*> data =
                    syncMsg;

                std::string packageName;
                if (syncMsg->data_as_state() && syncMsg->data_as_state()->attributes_as_syscollector_packages() &&
                    syncMsg->data_as_state()->attributes_as_syscollector_packages()->name())
                {
                    packageName = syncMsg->data_as_state()->attributes_as_syscollector_packages()->name()->c_str();
                }

                try
                {
                    scanOrchestrator->run(data);
                }
                catch (const OsDataException& e)
                {
                    m_syncQueue->push(std::move(std::string(message.data(), message.size())));
                    logDebug1(WM_VULNSCAN_LOGTAG,
                              "%s. syscollector_packages event postponed: %s package. Queue size: %d",
                              e.what(),
                              packageName,
                              m_syncQueue->size());
                }
                catch (const std::exception& e)
                {
                    logError(WM_VULNSCAN_LOGTAG, "ScanOrchestrator::run::Exception: %s", e.what());
                }
            });

        logInfo(WM_VULNSCAN_LOGTAG, "Vulnerability scanner module started");
    }
    catch (const std::exception& e)
    {
        logError(WM_VULNSCAN_LOGTAG, "VulnerabilityScannerFacade::start: %s", e.what());
    }
    catch (...)
    {
        logError(WM_VULNSCAN_LOGTAG, "VulnerabilityScannerFacade::start: Unknown exception");
    }
}
// LCOV_EXCL_STOP

void VulnerabilityScannerFacade::stop()
{
    if (m_noWaitToStop)
    {
        m_shouldStop.store(true);
    }

    m_stopRetryThread.store(true);

    if (m_deltaQueue)
    {
        m_deltaQueue->cancel();
    }
    if (m_syncQueue)
    {
        m_syncQueue->cancel();
    }

    if (m_deltaThread.joinable())
    {
        m_deltaThread.join();
    }
    if (m_syncThread.joinable())
    {
        m_syncThread.join();
    }

    m_deltaQueue.reset();
    m_syncQueue.reset();
    m_indexerConnector.reset();
    m_databaseFeedManager.reset();
    m_syscollectorRsyncSubscription.reset();
    m_syscollectorDeltasSubscription.reset();
    PolicyManager::instance().teardown();
}
