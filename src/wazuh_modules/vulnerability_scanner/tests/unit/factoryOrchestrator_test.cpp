/*
 * Wazuh Vulnerability Scanner - Unit Tests
 * Copyright (C) 2015, Wazuh Inc.
 * September 21, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#include "factoryOrchestrator_test.hpp"
#include "MockCleanUpPkgs.hpp"
#include "MockDetailsAugmentation.hpp"
#include "MockFetchAllGlobalDb.hpp"
#include "MockInventorySync.hpp"
#include "MockOsScanner.hpp"
#include "MockPackageScanner.hpp"
#include "MockResultIndexer.hpp"
#include "MockSendReport.hpp"

typedef enum HANDLERS
{
    PACKAGE_SCANNER,
    DETAILS_AUGMENTATION,
    OS_SCANNER,
    INVENTORY_SYNC,
    SEND_REPORT,
    RESULT_INDEXER,
    SIZE
} HANDLERS;

/*
 * @brief Test the chain creation for packages.
 */
TEST_F(FactoryOrchestratorTest, TestScannerTypePackageInsert)
{
    // Create the orchestrator for PackageInsert.
    std::shared_ptr<MockDatabaseFeedManager> mockDatabaseFeedManager;
    std::shared_ptr<MockIndexerConnector> mockIndexerConnector;

    MockPackageScanner mockPackageScanner(mockDatabaseFeedManager);
    MockDetailsAugmentation mockDetailsAugmentation(mockDatabaseFeedManager);
    MockOsScanner mockOsScanner;
    MockInventorySync mockInventorySync(*m_inventoryDatabase);
    MockResultIndexer mockResultIndexer(mockIndexerConnector);
    MockSendReport mockSendReport(NULL);

    std::shared_ptr<AbstractHandler<std::shared_ptr<std::vector<int>>>> orchestration =
        TFactoryOrchestrator<MockPackageScanner,
                             MockDetailsAugmentation,
                             MockOsScanner,
                             MockInventorySync,
                             MockSendReport,
                             MockResultIndexer,
                             MockDatabaseFeedManager,
                             MockIndexerConnector,
                             std::vector<int>,
                             MockFetchAllGlobalDb,
                             MockCleanUpPkgs>::create(ScannerType::PackageInsert,
                                                      NULL,
                                                      NULL,
                                                      *m_inventoryDatabase,
                                                      NULL);

    std::shared_ptr<std::vector<int>> context = std::make_shared<std::vector<int>>();

    EXPECT_NO_THROW(orchestration->handleRequest(context));
    EXPECT_EQ(context->size(), 5);
    EXPECT_EQ(context->at(0), HANDLERS::PACKAGE_SCANNER);
    EXPECT_EQ(context->at(1), HANDLERS::DETAILS_AUGMENTATION);
    EXPECT_EQ(context->at(2), HANDLERS::INVENTORY_SYNC);
    EXPECT_EQ(context->at(3), HANDLERS::SEND_REPORT);
    EXPECT_EQ(context->at(4), HANDLERS::RESULT_INDEXER);
}

/*
 * @brief Test the chain creation for packages.
 */
TEST_F(FactoryOrchestratorTest, TestScannerTypePackageDelete)
{
    // Create the orchestrator for PackageDelete.
    std::shared_ptr<MockDatabaseFeedManager> mockDatabaseFeedManager;
    std::shared_ptr<MockIndexerConnector> mockIndexerConnector;

    MockPackageScanner mockPackageScanner(mockDatabaseFeedManager);
    MockDetailsAugmentation mockDetailsAugmentation(mockDatabaseFeedManager);
    MockOsScanner mockOsScanner;
    MockInventorySync mockInventorySync(*m_inventoryDatabase);
    MockResultIndexer mockResultIndexer(mockIndexerConnector);
    MockSendReport mockSendReport(NULL);

    std::shared_ptr<AbstractHandler<std::shared_ptr<std::vector<int>>>> orchestration =
        TFactoryOrchestrator<MockPackageScanner,
                             MockDetailsAugmentation,
                             MockOsScanner,
                             MockInventorySync,
                             MockSendReport,
                             MockResultIndexer,
                             MockDatabaseFeedManager,
                             MockIndexerConnector,
                             std::vector<int>,
                             MockFetchAllGlobalDb,
                             MockCleanUpPkgs>::create(ScannerType::PackageDelete,
                                                      NULL,
                                                      NULL,
                                                      *m_inventoryDatabase,
                                                      NULL);

    std::shared_ptr<std::vector<int>> context = std::make_shared<std::vector<int>>();

    EXPECT_NO_THROW(orchestration->handleRequest(context));
    EXPECT_EQ(context->size(), 4);
    EXPECT_EQ(context->at(0), HANDLERS::INVENTORY_SYNC);
    EXPECT_EQ(context->at(1), HANDLERS::DETAILS_AUGMENTATION);
    EXPECT_EQ(context->at(2), HANDLERS::SEND_REPORT);
    EXPECT_EQ(context->at(3), HANDLERS::RESULT_INDEXER);
}

/*
 * @brief Test the chain creation for packages.
 */
TEST_F(FactoryOrchestratorTest, TestScannerTypeIntegrityClear)
{
    // Create the orchestrator for IntegrityClear.
    std::shared_ptr<MockDatabaseFeedManager> mockDatabaseFeedManager;
    std::shared_ptr<MockIndexerConnector> mockIndexerConnector;

    MockPackageScanner mockPackageScanner(mockDatabaseFeedManager);
    MockDetailsAugmentation mockDetailsAugmentation(mockDatabaseFeedManager);
    MockOsScanner mockOsScanner;
    MockInventorySync mockInventorySync(*m_inventoryDatabase);
    MockResultIndexer mockResultIndexer(mockIndexerConnector);
    MockSendReport mockSendReport(NULL);

    std::shared_ptr<AbstractHandler<std::shared_ptr<std::vector<int>>>> orchestration =
        TFactoryOrchestrator<MockPackageScanner,
                             MockDetailsAugmentation,
                             MockOsScanner,
                             MockInventorySync,
                             MockSendReport,
                             MockResultIndexer,
                             MockDatabaseFeedManager,
                             MockIndexerConnector,
                             std::vector<int>,
                             MockFetchAllGlobalDb,
                             MockCleanUpPkgs>::create(ScannerType::IntegrityClear,
                                                      NULL,
                                                      NULL,
                                                      *m_inventoryDatabase,
                                                      NULL);

    std::shared_ptr<std::vector<int>> context = std::make_shared<std::vector<int>>();

    EXPECT_NO_THROW(orchestration->handleRequest(context));
    EXPECT_EQ(context->size(), 4);
    EXPECT_EQ(context->at(0), HANDLERS::INVENTORY_SYNC);
    EXPECT_EQ(context->at(1), HANDLERS::DETAILS_AUGMENTATION);
    EXPECT_EQ(context->at(2), HANDLERS::SEND_REPORT);
    EXPECT_EQ(context->at(3), HANDLERS::RESULT_INDEXER);
}

/*
 * @brief Test the chain creation for os.
 */
TEST_F(FactoryOrchestratorTest, TestScannerTypeOs)
{
    // Create the orchestrator for Os.
    std::shared_ptr<MockDatabaseFeedManager> mockDatabaseFeedManager;
    std::shared_ptr<MockIndexerConnector> mockIndexerConnector;

    MockPackageScanner mockPackageScanner(mockDatabaseFeedManager);
    MockDetailsAugmentation mockDetailsAugmentation(mockDatabaseFeedManager);
    MockOsScanner mockOsScanner;
    MockInventorySync mockInventorySync(*m_inventoryDatabase);
    MockResultIndexer mockResultIndexer(mockIndexerConnector);
    MockSendReport mockSendReport(NULL);

    std::shared_ptr<AbstractHandler<std::shared_ptr<std::vector<int>>>> orchestration =
        TFactoryOrchestrator<MockPackageScanner,
                             MockDetailsAugmentation,
                             MockOsScanner,
                             MockInventorySync,
                             MockSendReport,
                             MockResultIndexer,
                             MockDatabaseFeedManager,
                             MockIndexerConnector,
                             std::vector<int>,
                             MockFetchAllGlobalDb,
                             MockCleanUpPkgs>::create(ScannerType::Os, NULL, NULL, *m_inventoryDatabase, NULL);

    std::shared_ptr<std::vector<int>> context = std::make_shared<std::vector<int>>();

    EXPECT_NO_THROW(orchestration->handleRequest(context));
    EXPECT_EQ(context->size(), 4);
    EXPECT_EQ(context->at(0), HANDLERS::OS_SCANNER);
    EXPECT_EQ(context->at(1), HANDLERS::INVENTORY_SYNC);
    EXPECT_EQ(context->at(2), HANDLERS::SEND_REPORT);
    EXPECT_EQ(context->at(3), HANDLERS::RESULT_INDEXER);
}

/*
 * @brief Test the chain creation for hotfixes.
 */
TEST_F(FactoryOrchestratorTest, TestScannerTypeHotfixInsert)
{
    // Create the orchestrator for HotfixInsert.
    std::shared_ptr<MockDatabaseFeedManager> mockDatabaseFeedManager;
    std::shared_ptr<MockIndexerConnector> mockIndexerConnector;

    MockPackageScanner mockPackageScanner(mockDatabaseFeedManager);
    MockDetailsAugmentation mockDetailsAugmentation(mockDatabaseFeedManager);
    MockOsScanner mockOsScanner;
    MockInventorySync mockInventorySync(*m_inventoryDatabase);
    MockResultIndexer mockResultIndexer(mockIndexerConnector);
    MockSendReport mockSendReport(NULL);

    std::shared_ptr<AbstractHandler<std::shared_ptr<std::vector<int>>>> orchestration =
        TFactoryOrchestrator<MockPackageScanner,
                             MockDetailsAugmentation,
                             MockOsScanner,
                             MockInventorySync,
                             MockSendReport,
                             MockResultIndexer,
                             MockDatabaseFeedManager,
                             MockIndexerConnector,
                             std::vector<int>,
                             MockFetchAllGlobalDb,
                             MockCleanUpPkgs>::create(ScannerType::HotfixInsert,
                                                      NULL,
                                                      NULL,
                                                      *m_inventoryDatabase,
                                                      NULL);

    std::shared_ptr<std::vector<int>> context = std::make_shared<std::vector<int>>();

    EXPECT_NO_THROW(orchestration->handleRequest(context));
    EXPECT_EQ(context->size(), 3);
    EXPECT_EQ(context->at(0), HANDLERS::INVENTORY_SYNC);
    EXPECT_EQ(context->at(1), HANDLERS::SEND_REPORT);
    EXPECT_EQ(context->at(2), HANDLERS::RESULT_INDEXER);
}

/*
 * @brief Test the chain creation for hotfixes.
 */
TEST_F(FactoryOrchestratorTest, TestScannerTypeHotfixDelete)
{
    // Create the orchestrator for HotfixDelete.
    std::shared_ptr<MockDatabaseFeedManager> mockDatabaseFeedManager;
    std::shared_ptr<MockIndexerConnector> mockIndexerConnector;

    MockPackageScanner mockPackageScanner(mockDatabaseFeedManager);
    MockDetailsAugmentation mockDetailsAugmentation(mockDatabaseFeedManager);
    MockOsScanner mockOsScanner;
    MockInventorySync mockInventorySync(*m_inventoryDatabase);
    MockResultIndexer mockResultIndexer(mockIndexerConnector);
    MockSendReport mockSendReport(NULL);

    std::shared_ptr<AbstractHandler<std::shared_ptr<std::vector<int>>>> orchestration =
        TFactoryOrchestrator<MockPackageScanner,
                             MockDetailsAugmentation,
                             MockOsScanner,
                             MockInventorySync,
                             MockSendReport,
                             MockResultIndexer,
                             MockDatabaseFeedManager,
                             MockIndexerConnector,
                             std::vector<int>,
                             MockFetchAllGlobalDb,
                             MockCleanUpPkgs>::create(ScannerType::HotfixDelete,
                                                      NULL,
                                                      NULL,
                                                      *m_inventoryDatabase,
                                                      NULL);

    std::shared_ptr<std::vector<int>> context = std::make_shared<std::vector<int>>();

    EXPECT_NO_THROW(orchestration->handleRequest(context));
    EXPECT_EQ(context->size(), 3);
    EXPECT_EQ(context->at(0), HANDLERS::INVENTORY_SYNC);
    EXPECT_EQ(context->at(1), HANDLERS::SEND_REPORT);
    EXPECT_EQ(context->at(2), HANDLERS::RESULT_INDEXER);
}

/*
 * @brief Test the creation of an invalid scanner.
 */
TEST_F(FactoryOrchestratorTest, TestCreationInvalidScannerType)
{
    // Create the orchestrator with invalid ScannerType.
    std::shared_ptr<MockDatabaseFeedManager> mockDatabaseFeedManager;
    std::shared_ptr<MockIndexerConnector> mockIndexerConnector;

    MockPackageScanner mockPackageScanner(mockDatabaseFeedManager);
    MockDetailsAugmentation mockDetailsAugmentation(mockDatabaseFeedManager);
    MockOsScanner mockOsScanner;
    MockInventorySync mockInventorySync(*m_inventoryDatabase);
    MockResultIndexer mockResultIndexer(mockIndexerConnector);
    MockSendReport mockSendReport(NULL);

    ScannerType invalidScannerType {-1};

    try
    {
        TFactoryOrchestrator<MockPackageScanner,
                             MockDetailsAugmentation,
                             MockOsScanner,
                             MockInventorySync,
                             MockSendReport,
                             MockResultIndexer,
                             MockDatabaseFeedManager,
                             MockIndexerConnector,
                             std::vector<int>,
                             MockFetchAllGlobalDb,
                             MockCleanUpPkgs>::create(invalidScannerType, NULL, NULL, *m_inventoryDatabase, NULL);
    }
    catch (const std::runtime_error& e)
    {
        EXPECT_STREQ(e.what(), "Invalid scanner type");
    }
    catch (...)
    {
        FAIL() << "Expected std::runtime_error";
    }
}
